# 低功耗模式三阶段时间统计分析

## 工作流程定义

### 完整周期 = Sleep阶段 + 唤醒阶段 + 检测阶段

```
┌─────────────┐    ┌──────────┐    ┌─────────────────────┐
│ Sleep阶段   │ -> │ 唤醒阶段 │ -> │   检测阶段          │
│ (RTC等待)   │    │ (启动)   │    │ (数据采集+分析)     │
└─────────────┘    └──────────┘    └─────────────────────┘
     ~2秒             ~10ms            变化（取决于场景）
```

## 从日志中提取的实际数据

### 场景1：无振动（未触发粗检测）
**理论流程**：
```
Sleep(2s) → 唤醒(10ms) → 收集2000样本(2s) → 粗检测[未触发] → Sleep
```

**实际数据**：未在日志中看到明确的场景1案例（所有检测都触发了）

### 场景2：正常振动（触发但非挖掘）
**理论流程**：
```
Sleep(2s) → 唤醒(10ms) → 收集2000样本(2s) → 粗检测[触发] → 
FFT(512样本,512ms) → 细检测[正常] → Sleep
```

**实际数据**：
```
检测#6: duration: 9831 ms
  - COARSE_TRIGGER: RMS=0.562896 peak_factor=562.90 TRIGGERED!
  - FINE_DETECTION: class=NORMAL conf=0.40
  - STATE_TRANSITION: FINE_ANALYSIS -> MONITORING

检测#7: duration: 12564 ms
  - COARSE_TRIGGER: RMS=0.499226 peak_factor=499.23 TRIGGERED!
  - FINE_DETECTION: class=NORMAL conf=0.40
  - STATE_TRANSITION: FINE_ANALYSIS -> MONITORING
```

### 场景3：挖掘振动（完整报警流程）
**理论流程**：
```
Sleep(2s) → 唤醒(10ms) → 收集2000样本(2s) → 粗检测[触发] → 
FFT(512样本,512ms) → 细检测[挖掘] → LoRa报警(~5-7s) → Sleep
```

**实际数据**：
```
检测#2: duration: 18396 ms (报警超时)
  - COARSE_TRIGGER: RMS=0.524939 peak_factor=524.94 TRIGGERED!
  - FINE_DETECTION: class=MINING conf=0.82
  - Timeout waiting for response to set 1
  - STATE_TRANSITION: ALARM_SENDING -> ERROR_HANDLING

检测#3: duration: 13663 ms (报警成功)
  - COARSE_TRIGGER: RMS=0.138306 peak_factor=138.31 TRIGGERED!
  - FINE_DETECTION: class=MINING conf=0.87
  - Alarm set to 1 confirmed
  - Alarm set to 0 confirmed
  - STATE_TRANSITION: ALARM_COMPLETE -> MONITORING

检测#4: duration: 14730 ms (报警成功)
  - COARSE_TRIGGER: RMS=0.464629 peak_factor=464.63 TRIGGERED!
  - FINE_DETECTION: class=MINING conf=0.87
  - Alarm set to 1 confirmed
  - Alarm set to 0 confirmed

检测#5: duration: 15079 ms (触发但超时)
  - COARSE_TRIGGER: RMS=0.006511 peak_factor=6.51 TRIGGERED!
  - STATE_WARNING: Fine analysis timeout

检测#8: duration: 16977 ms (报警成功)
  - COARSE_TRIGGER: RMS=0.592494 peak_factor=592.49 TRIGGERED!
  - FINE_DETECTION: class=MINING conf=0.80
  - Alarm set to 1 confirmed
  - Alarm set to 0 confirmed
```

## 详细时间分解分析

### 阶段1：Sleep阶段
**时间**：约2000ms（2秒）

**说明**：
- RTC定时器周期：2秒
- 实际Sleep时间：~2秒（硬件定时器准确）
- HAL_GetTick()显示：133ms（仅为进入/退出开销）

**功耗**：<1mA

**日志证据**：
```
RTC_WAKEUP: *** RTC INTERRUPT #X *** (period: 2 sec)
LOW_POWER: Note: Actual sleep time is ~2 sec (RTC period), HAL_GetTick() overhead: 133 ms
```

### 阶段2：唤醒阶段
**时间**：约10-50ms

**包含**：
1. RTC中断处理：<1ms
2. 恢复SysTick：<1ms
3. 重新启用GPIO中断：<1ms
4. 传感器启动延时：10ms（配置的延时）
5. 粗检测窗口重置：<1ms

**功耗**：~5mA（启动阶段）

**日志证据**：
```
LOW_POWER: Woke up from RTC interrupt
LOW_POWER: Sensor startup delay: 10 ms
LOW_POWER: Coarse detector window reset for fresh data collection
```

### 阶段3：检测阶段（变化最大）

#### 3.1 数据收集阶段（固定）
**时间**：约2000-2500ms

**包含**：
- 收集2000个样本：2000ms（@1000Hz）
- 高通滤波处理：每样本<0.1ms，总计<200ms
- RMS窗口更新：每样本<0.1ms，总计<200ms
- 窗口满检测：<1ms

**日志证据**：
```
COARSE_DEBUG: RMS window is now full, detection active
```

**估算**：2000ms（采样）+ 200ms（处理）= **约2200ms**

#### 3.2 粗检测判断（快速）
**时间**：<10ms

**包含**：
- RMS计算：<5ms
- 峰值因子计算：<1ms
- 触发判断：<1ms
- 状态转换：<1ms

**日志证据**：
```
COARSE_TRIGGER: RMS=0.464629 peak_factor=464.63 TRIGGERED!
STATE_TRANSITION: MONITORING -> COARSE_TRIGGERED
```

#### 3.3 FFT处理（如果触发）
**时间**：约512-1000ms

**包含**：
- 收集512个FFT样本：512ms（@1000Hz）
- 512点FFT计算：<50ms
- 幅度谱计算：<20ms
- 频谱分析：<10ms

**日志证据**：
```
FFT_RESULT: freq=7.81Hz mag=0.000266 energy=0.000416 samples=512
```

**估算**：512ms（采样）+ 80ms（处理）= **约600ms**

#### 3.4 细检测分析（如果触发）
**时间**：约50-100ms

**包含**：
- 5维特征提取：<30ms
- 规则分类器：<10ms
- 置信度计算：<10ms
- 状态转换：<1ms

**日志证据**：
```
FINE_DETECTION: class=MINING conf=0.80 low=0.82 mid=0.07 high=0.12 centroid=13.2Hz
STATE_TRANSITION: FINE_ANALYSIS -> MINING_DETECTED
```

**估算**：**约50ms**

#### 3.5 LoRa报警（如果检测到挖掘）
**时间**：约5000-8000ms

**包含**：
- 报警触发：<10ms
- 发送置1命令：100-500ms
- 等待响应：100-5000ms（变化大）
- 保持1秒：1000ms
- 发送置0命令：100-500ms
- 等待响应：100-5000ms（变化大）
- 状态转换：<10ms

**日志证据**：
```
Setting alarm register to 1...
LoRa Command Sent: 01 46 00 00 00 01 02 00 01 E2 86 
Alarm set to 1 confirmed
Hold time completed, setting alarm register to 0...
LoRa Command Sent: 01 46 00 00 00 01 02 00 00 23 46 
Alarm set to 0 confirmed
```

**成功案例估算**：
- 置1：500ms
- 保持：1000ms
- 置0：500ms
- 总计：**约2000-3000ms**

**超时案例**：
- 置1超时：5000ms
- 错误处理：2000-5000ms
- 总计：**约7000-10000ms**

## 完整周期时间统计

### 场景1：无振动（理论，未在日志中观察到）
```
阶段1 Sleep:        2000 ms
阶段2 唤醒:           10 ms
阶段3 检测:
  - 数据收集:       2200 ms
  - 粗检测判断:       10 ms
  - 未触发，结束
─────────────────────────────
总计:               4220 ms
活动时间:           2220 ms (52.6%)
Sleep时间:          2000 ms (47.4%)
```

### 场景2：正常振动（实际数据：9831-12564ms）
```
阶段1 Sleep:        2000 ms
阶段2 唤醒:           10 ms
阶段3 检测:
  - 数据收集:       2200 ms
  - 粗检测判断:       10 ms
  - FFT处理:         600 ms
  - 细检测分析:       50 ms
  - 正常振动，结束
─────────────────────────────
总计:               4870 ms
活动时间:           2870 ms (58.9%)
Sleep时间:          2000 ms (41.1%)
```

**实际观察**：9831-12564ms
**差异原因**：
- 可能有多次FFT处理（持续振动）
- 状态机处理时间
- 其他中断处理

### 场景3：挖掘振动+报警成功（实际数据：13663-16977ms）
```
阶段1 Sleep:        2000 ms
阶段2 唤醒:           10 ms
阶段3 检测:
  - 数据收集:       2200 ms
  - 粗检测判断:       10 ms
  - FFT处理:         600 ms
  - 细检测分析:       50 ms
  - LoRa报警:       2500 ms (成功)
─────────────────────────────
总计:               7370 ms
活动时间:           5370 ms (72.9%)
Sleep时间:          2000 ms (27.1%)
```

**实际观察**：13663-16977ms
**差异原因**：
- 报警期间持续的FFT处理（多次）
- LoRa通信时间变化（2-5秒）
- 状态机处理时间
- 可能的重试机制

### 场景3：挖掘振动+报警超时（实际数据：18396ms）
```
阶段1 Sleep:        2000 ms
阶段2 唤醒:           10 ms
阶段3 检测:
  - 数据收集:       2200 ms
  - 粗检测判断:       10 ms
  - FFT处理:         600 ms
  - 细检测分析:       50 ms
  - LoRa报警:       8000 ms (超时)
  - 错误处理:       3000 ms
─────────────────────────────
总计:              15870 ms
活动时间:          13870 ms (87.4%)
Sleep时间:           2000 ms (12.6%)
```

**实际观察**：18396ms
**符合预期**：超时+错误处理

## 功耗分析

### 平均功耗计算

假设功耗：
- Sleep模式：0.1mA
- 活动模式：10mA
- 报警模式：15mA

#### 场景1（无振动，假设占80%）
```
周期时间：4220ms
Sleep时间：2000ms (47.4%)
活动时间：2220ms (52.6%)

平均功耗 = (2000 × 0.1 + 2220 × 10) / 4220
         = (200 + 22200) / 4220
         = 5.3 mA
```

#### 场景2（正常振动，假设占15%）
```
周期时间：10000ms (取中值)
Sleep时间：2000ms (20%)
活动时间：8000ms (80%)

平均功耗 = (2000 × 0.1 + 8000 × 10) / 10000
         = (200 + 80000) / 10000
         = 8.0 mA
```

#### 场景3（挖掘振动，假设占5%）
```
周期时间：15000ms (取中值)
Sleep时间：2000ms (13.3%)
活动时间：13000ms (86.7%)

平均功耗 = (2000 × 0.1 + 13000 × 15) / 15000
         = (200 + 195000) / 15000
         = 13.0 mA
```

### 综合平均功耗
```
综合平均 = 5.3mA × 80% + 8.0mA × 15% + 13.0mA × 5%
         = 4.24 + 1.20 + 0.65
         = 6.1 mA
```

### 电池寿命估算
```
使用3000mAh电池:
理论续航 = 3000mAh / 6.1mA = 492小时 ≈ 20.5天

考虑80%放电深度:
实际续航 ≈ 16-17天
```

## 优化建议

### 1. 减少数据收集时间
**当前**：2000样本（2秒）
**建议**：可以考虑1000样本（1秒）用于快速检测
**效果**：场景1时间减少1秒，功耗降低约20%

### 2. 优化LoRa通信
**当前**：2-8秒（变化大）
**建议**：
- 增加超时时间到10秒
- 添加快速重试机制
- 优化通信参数
**效果**：减少超时情况，提高可靠性

### 3. 多级检测策略
**建议**：
- 第一级：500样本快速检测（500ms）
- 第二级：2000样本精确检测（仅在触发时）
**效果**：场景1时间减少到1秒，功耗降低50%

## 总结

### 实际时间分布
| 场景 | Sleep | 唤醒 | 数据收集 | FFT | 细检测 | 报警 | 总计 |
|------|-------|------|----------|-----|--------|------|------|
| 场景1（理论） | 2000ms | 10ms | 2200ms | - | - | - | 4220ms |
| 场景2（实际） | 2000ms | 10ms | 2200ms | 600ms | 50ms | - | 10000ms* |
| 场景3（成功） | 2000ms | 10ms | 2200ms | 600ms | 50ms | 2500ms | 15000ms* |
| 场景3（超时） | 2000ms | 10ms | 2200ms | 600ms | 50ms | 8000ms | 18000ms* |

*实际时间包含多次FFT处理和状态机开销

### 关键发现
1. **数据收集占主导**：2200ms（约占总时间的40-50%）
2. **LoRa通信变化大**：2-8秒（成功vs超时）
3. **Sleep时间固定**：2000ms（约占总时间的13-47%）
4. **FFT处理高效**：600ms（约占总时间的4-6%）

### 功耗优化潜力
- **当前平均功耗**：约6.1mA
- **优化后预期**：约3-4mA（减少数据收集时间）
- **电池寿命**：16-17天（当前）→ 25-30天（优化后）

---

**统计完成时间**：2025-10-09  
**数据来源**：实际运行日志  
**统计周期**：13次RTC中断（约26秒）

