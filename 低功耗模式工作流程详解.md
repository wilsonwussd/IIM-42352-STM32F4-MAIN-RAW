# 低功耗模式工作流程详解

## 核心问题回答

**问题**：现在是不是 开始启动睡眠-2秒后唤醒 立刻读加速度数据，确认是否触发启动细检测（进入FFT）。如果没触发就进入睡眠 等2s再 启动上面过程呢？

**答案**：✅ **是的，但有一个重要细节需要说明**

## 完整工作流程

### 主循环结构（main.c）

```c
do {
    /* 1. 检查是否有RTC唤醒事件 */
    if (RTC_Wakeup_IsPending()) {
        /* 2. 处理RTC唤醒 */
        LowPower_HandleWakeup();
        
        /* 3. 启动检测流程 */
        LowPower_StartDetectionProcess();
        
        /* 4. 运行检测流程直到完成 */
        do {
            /* 4.1 读取传感器数据（如果有中断） */
            if (irq_from_device & TO_MASK(INV_GPIO_INT1)) {
                rc = GetDataFromInvDevice();  // 这里会处理加速度数据
                irq_from_device &= ~TO_MASK(INV_GPIO_INT1);
            }
            
            /* 4.2 处理报警状态机 */
            Process_Alarm_State_Machine();
            
            /* 4.3 处理系统状态机 */
            System_State_Machine_Process();
            
            HAL_Delay(1);
            
        } while (!LowPower_IsDetectionComplete());  // 检测完成判断
    }
    
    /* 5. 进入Sleep模式等待下次唤醒 */
    LowPower_EnterSleep();
    
} while(1);
```

## 详细流程分解

### 阶段1：Sleep模式（约2秒）

```
系统状态：STM32 Sleep模式
功耗：<1mA
RTC定时器：持续计数
等待：RTC唤醒中断（2秒周期）
```

### 阶段2：RTC唤醒（瞬间）

```c
// RTC中断触发
void HAL_RTCEx_WakeUpTimerEventCallback(RTC_HandleTypeDef *hrtc)
{
    // 设置唤醒标志
    g_rtc_wakeup_pending = true;
}
```

### 阶段3：唤醒处理（约10ms）

```c
LowPower_HandleWakeup();
// - 恢复SysTick
// - 重新启用传感器GPIO中断
// - 打印唤醒信息
```

### 阶段4：启动检测流程（瞬间）

```c
LowPower_StartDetectionProcess();
// - 记录检测开始时间
// - 打印场景分析开始信息
```

### 阶段5：数据采集和处理（关键部分）

**重要说明**：这里不是"立刻读取一次数据"，而是**持续读取数据直到满足条件**

#### 5.1 传感器数据采集（1000Hz）

```c
// 传感器以1000Hz产生数据，通过GPIO中断通知
if (irq_from_device & TO_MASK(INV_GPIO_INT1)) {
    GetDataFromInvDevice();  // 读取FIFO中的数据
}
```

#### 5.2 数据处理流程（每个样本）

```c
// 在GetDataFromInvDevice()中，对每个加速度样本：

// 1. 高通滤波（5Hz截止）
float32_t filtered_z_g = Highpass_Filter_Process(accel_z_g);

// 2. 粗检测处理（RMS滑动窗口）
int trigger_detected = Coarse_Detector_Process(filtered_z_g);

// 3. 判断是否触发FFT
coarse_detection_state_t current_state = Coarse_Detector_GetState();
bool should_trigger = (trigger_detected ||
                      current_state == COARSE_STATE_TRIGGERED ||
                      current_state == COARSE_STATE_COOLDOWN);
FFT_SetTriggerState(should_trigger);

// 4. FFT处理（如果触发）
int result = FFT_AddSample(filtered_z_g);
```

#### 5.3 粗检测算法详解

**关键参数**：
- **RMS窗口大小**：200个样本（200ms @ 1000Hz）
- **触发阈值**：1.5倍基线RMS
- **基线RMS**：0.001g（1mg）

**工作原理**：
```c
// 需要收集200个样本才能开始检测
if (coarse_detector.window_full) {
    // 计算当前RMS
    coarse_detector.current_rms = sqrtf(sum_squares / RMS_WINDOW_SIZE);
    
    // 计算峰值因子
    coarse_detector.peak_factor = coarse_detector.current_rms / coarse_detector.baseline_rms;
    
    // 判断是否触发
    if (coarse_detector.peak_factor > TRIGGER_MULTIPLIER) {
        // 触发！进入TRIGGERED状态
        coarse_detector.state = COARSE_STATE_TRIGGERED;
        return 1;  // 触发检测到
    }
}
```

**时间计算**：
- 200个样本 @ 1000Hz = 200ms
- 所以至少需要200ms才能完成第一次粗检测判断

### 阶段6：检测完成判断

```c
bool LowPower_IsDetectionComplete(void)
{
    // 1. 传感器空闲（没有待处理的中断）
    bool sensor_idle = (irq_from_device == 0);
    
    // 2. 状态机空闲（MONITORING/IDLE_SLEEP/ALARM_COMPLETE）
    system_state_t current_state = System_State_Machine_GetCurrentState();
    bool state_machine_idle = (current_state == STATE_MONITORING ||
                              current_state == STATE_IDLE_SLEEP ||
                              current_state == STATE_ALARM_COMPLETE);
    
    // 3. 报警空闲
    bool alarm_idle = true;
    
    // 全部满足才认为检测完成
    return sensor_idle && state_machine_idle && alarm_idle;
}
```

### 阶段7：返回Sleep模式

```c
LowPower_EnterSleep();
// - 暂停SysTick
// - 禁用传感器GPIO中断
// - 进入STM32 Sleep模式
// - 等待下一次RTC唤醒
```

## 三种典型场景

### 场景1：无振动（快速完成，约265ms）

```
Sleep → RTC唤醒 → 启动检测 → 收集200个样本 → 粗检测[未触发] → Sleep
                                (200ms)        (65ms处理)
```

**流程**：
1. 收集200个样本（200ms）
2. 粗检测判断：RMS < 1.5倍基线
3. 不触发FFT
4. 状态机保持MONITORING状态
5. 检测完成，返回Sleep

### 场景2：正常振动（中等时长，约333ms）

```
Sleep → RTC唤醒 → 启动检测 → 收集200个样本 → 粗检测[触发] → 收集512个样本 → FFT处理 → 细检测[正常] → Sleep
                                (200ms)        触发!        (512ms)      (快速)    (正常振动)
```

**流程**：
1. 收集200个样本（200ms）
2. 粗检测判断：RMS > 1.5倍基线，**触发！**
3. 启动FFT采样
4. 收集512个样本（512ms）
5. FFT处理和细检测
6. 识别为正常振动
7. 状态机：MONITORING → COARSE_TRIGGERED → FINE_ANALYSIS → MONITORING
8. 检测完成，返回Sleep

### 场景3：挖掘振动（长时间，约5641ms）

```
Sleep → RTC唤醒 → 启动检测 → 收集200个样本 → 粗检测[触发] → 收集512个样本 → FFT处理 → 细检测[挖掘] → LoRa报警 → Sleep
                                (200ms)        触发!        (512ms)      (快速)    (挖掘!)     (约5秒)
```

**流程**：
1. 收集200个样本（200ms）
2. 粗检测判断：RMS > 1.5倍基线，**触发！**
3. 启动FFT采样
4. 收集512个样本（512ms）
5. FFT处理和细检测
6. 识别为挖掘振动
7. 状态机：MONITORING → COARSE_TRIGGERED → FINE_ANALYSIS → MINING_DETECTED → ALARM_SENDING → ALARM_COMPLETE
8. LoRa报警发送（约5秒）
9. 检测完成，返回Sleep

## 关键技术细节

### 1. 不是"读一次数据"，而是"持续读取直到完成"

**误解**：唤醒后读取一次加速度数据，判断是否触发

**实际**：唤醒后持续读取数据（1000Hz），直到满足以下条件之一：
- 收集200个样本后粗检测未触发（场景1）
- 完成完整检测流程（场景2/3）

### 2. 粗检测需要200个样本（200ms）

**原因**：
- RMS滑动窗口需要200个样本才能计算
- 这是统计学上的要求，确保检测准确性

**时间**：
- 200个样本 @ 1000Hz = 200ms
- 所以最快也要200ms才能完成第一次判断

### 3. 检测完成的判断条件

**不是简单的"读完数据就完成"**，而是：
1. 传感器FIFO已清空（没有待处理数据）
2. 状态机处于稳定状态（MONITORING/IDLE_SLEEP/ALARM_COMPLETE）
3. 报警流程已完成（如果有）

### 4. FFT触发控制

**智能触发**：
- 未触发时：完全跳过FFT采样，节省功耗
- 触发后：收集512个样本进行FFT分析
- 触发状态持续2秒（TRIGGER_DURATION_MS）

## 功耗分析

### 时间占比

| 阶段 | 时间 | 占比 | 功耗 |
|------|------|------|------|
| Sleep模式 | ~2000ms | 70-87% | <1mA |
| 检测处理 | 265-603ms | 13-30% | ~15mA |
| 报警发送 | ~5000ms | <1% | ~25mA |

### 平均功耗计算

**场景1（无振动，最常见）**：
```
平均功耗 = (2000ms × 0.1mA + 265ms × 15mA) / 2265ms
         = (200 + 3975) / 2265
         ≈ 1.8mA
```

**场景2（正常振动）**：
```
平均功耗 = (2000ms × 0.1mA + 333ms × 15mA) / 2333ms
         = (200 + 4995) / 2333
         ≈ 2.2mA
```

**场景3（挖掘振动，罕见）**：
```
平均功耗 = (2000ms × 0.1mA + 5641ms × 20mA) / 7641ms
         = (200 + 112820) / 7641
         ≈ 14.8mA
```

**综合平均**（假设99%场景1，0.9%场景2，0.1%场景3）：
```
平均功耗 ≈ 1.8mA × 0.99 + 2.2mA × 0.009 + 14.8mA × 0.001
         ≈ 1.78 + 0.02 + 0.015
         ≈ 1.8-2.0mA
```

## 总结

### 回答原问题

**是的，流程基本正确，但有重要补充**：

✅ **正确部分**：
1. 系统从Sleep模式开始
2. 2秒后RTC唤醒
3. 读取加速度数据
4. 判断是否触发细检测（FFT）
5. 如果没触发就进入Sleep
6. 等待2秒再重复

⚠️ **重要补充**：
1. **不是"读一次数据"**，而是持续读取直到满足条件
2. **至少需要200ms**（200个样本）才能完成第一次粗检测判断
3. **如果触发**，还需要额外512ms收集FFT样本
4. **检测完成判断**基于多个条件，不仅仅是数据读取完成

### 关键优势

1. **智能功耗管理**：根据振动情况自适应处理时间
2. **完整算法复用**：100%保持现有检测精度
3. **快速响应**：无振动时仅265ms即可返回Sleep
4. **可靠检测**：有振动时完整执行检测流程

---

**文档版本**：v1.0  
**创建日期**：2025-10-09  
**适用版本**：v4.0-stage6-rtc-low-power

