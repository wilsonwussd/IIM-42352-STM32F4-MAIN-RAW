# ä¸Šä½æœºæ™ºèƒ½æŒ–æ˜æ£€æµ‹ç³»ç»Ÿä»£ç æ¶æ„æ–‡æ¡£

## ğŸ“‹ é¡¹ç›®æ¦‚è¿°

åŸºäºPythonçš„ä¸“ä¸šæŒ¯åŠ¨åˆ†æä¸Šä½æœºè½¯ä»¶ï¼Œé›†æˆæ™ºèƒ½æŒ–æ˜æ£€æµ‹ç®—æ³•ã€åŒè§†å›¾æ˜¾ç¤ºç•Œé¢å’ŒSTM32æŠ¥è­¦è§¦å‘åŠŸèƒ½ã€‚

### æŠ€æœ¯è§„æ ¼
- **å¼€å‘è¯­è¨€**: Python 3.x
- **GUIæ¡†æ¶**: Tkinter + Matplotlib
- **é€šä¿¡åè®®**: ä¸²å£é€šä¿¡ (115200bps)
- **æ•°æ®å¤„ç†**: NumPy + SciPy
- **æ™ºèƒ½æ£€æµ‹**: ä¸¤çº§æ£€æµ‹ç®—æ³• (ç²—æ£€æµ‹+ç»†æ£€æµ‹)

## ğŸ—ï¸ ç³»ç»Ÿæ¶æ„

### è½¯ä»¶æ¶æ„
```
ç”¨æˆ·ç•Œé¢å±‚ â†’ æ•°æ®å¤„ç†å±‚ â†’ æ™ºèƒ½æ£€æµ‹å±‚ â†’ é€šä¿¡æ§åˆ¶å±‚ â†’ æ—¥å¿—è®°å½•å±‚
    â†“           â†“           â†“           â†“           â†“
Tkinter GUI  åè®®è§£æå™¨   ä¸¤çº§æ£€æµ‹å™¨   ä¸²å£ç®¡ç†å™¨   äº‹ä»¶è®°å½•å™¨
åŒè§†å›¾æ˜¾ç¤º   æ•°æ®é¢„å¤„ç†   è§„åˆ™åˆ†ç±»å™¨   å‘½ä»¤å‘é€å™¨   æ—¥å¿—ç³»ç»Ÿ
```

### æ•°æ®æµæ¶æ„
```
STM32æ•°æ® â†’ åè®®è§£æ â†’ æ•°æ®é¢„å¤„ç† â†’ æ™ºèƒ½æ£€æµ‹ â†’ ç»“æœæ˜¾ç¤º â†’ æŠ¥è­¦è§¦å‘
    â†“         â†“         â†“         â†“         â†“         â†“
ä¸²å£æ¥æ”¶   å¸§è§£æ     é«˜é€šæ»¤æ³¢   ä¸¤çº§ç®—æ³•   GUIæ›´æ–°   0x10å‘½ä»¤
å¤šçº¿ç¨‹     æ ¡éªŒå’Œ     ç‰¹å¾æå–   ç½®ä¿¡åº¦     å®æ—¶å›¾è¡¨   LoRaæŠ¥è­¦
```

## ğŸ“ æ ¸å¿ƒæ¨¡å—æ¶æ„

### 1. åè®®è§£ææ¨¡å— (ProtocolParserç±»)

#### 1.1 æ•°æ®ç»“æ„
```python
class ProtocolParser:
    def __init__(self):
        self.buffer = bytearray()  # æ¥æ”¶ç¼“å†²åŒº
        
    def add_data(self, data):
        """æ·»åŠ æ•°æ®å¹¶è§£æå¸§"""
        self.buffer.extend(data)
        frames = []
        
        while len(self.buffer) >= 10:
            # æŸ¥æ‰¾å¸§å¤´ AA55
            frame_start = self._find_frame_header()
            if frame_start == -1:
                break
                
            # è§£æå¸§ç»“æ„
            frame = self._parse_frame()
            if frame:
                frames.append(frame)
                
        return frames
```

#### 1.2 å¸§è§£æé€»è¾‘
```python
def _parse_payload(self, cmd, payload):
    """è§£æè½½è·æ•°æ® - ä¿æŒåŸå§‹ç²¾åº¦"""
    if cmd == 0x01 and len(payload) >= 88:  # 21ç‚¹é¢‘åŸŸæ•°æ®
        timestamp = struct.unpack('<I', payload[:4])[0]
        magnitudes = []
        for i in range(4, 88, 4):
            mag = struct.unpack('<f', payload[i:i+4])[0]
            magnitudes.append(mag)  # ä¿æŒåŸå§‹æ•°æ®
        frequencies = [i * 25.0 for i in range(21)]
        return {
            'type': 'spectrum',
            'timestamp': timestamp,
            'frequencies': frequencies,
            'magnitudes': magnitudes,
            'data_points': 21
        }
    
    elif cmd == 0x04 and len(payload) >= 1032:  # 257ç‚¹é«˜åˆ†è¾¨ç‡æ•°æ®
        timestamp = struct.unpack('<I', payload[:4])[0]
        magnitudes = []
        for i in range(4, 1032, 4):
            mag = struct.unpack('<f', payload[i:i+4])[0]
            magnitudes.append(mag)
        frequencies = [i * 1.953125 for i in range(257)]  # 1000Hz/512ç‚¹
        return {
            'type': 'spectrum',
            'timestamp': timestamp,
            'frequencies': frequencies,
            'magnitudes': magnitudes,
            'data_points': 257
        }
    
    elif cmd == 0x02 and len(payload) >= 16:  # åŸå§‹åŠ é€Ÿåº¦æ•°æ®
        timestamp = struct.unpack('<I', payload[:4])[0]
        accel_x = struct.unpack('<f', payload[4:8])[0]
        accel_y = struct.unpack('<f', payload[8:12])[0]
        accel_z = struct.unpack('<f', payload[12:16])[0]
        return {
            'type': 'raw_accel',
            'timestamp': timestamp,
            'accel_x': accel_x,
            'accel_y': accel_y,
            'accel_z': accel_z
        }
```

### 2. æ•°æ®é¢„å¤„ç†æ¨¡å— (DataPreprocessorç±»)

#### 2.1 é«˜é€šæ»¤æ³¢å™¨è®¾è®¡
```python
class DataPreprocessor:
    def __init__(self, param_manager):
        self.param_manager = param_manager
        self.filter_initialized = False
        self.sos = None
        # ä¸ºæ¯ä¸ªè½´ç»´æŠ¤ç‹¬ç«‹çš„æ»¤æ³¢å™¨çŠ¶æ€
        self.zi_x = None
        self.zi_y = None
        self.zi_z = None
        self.setup_filter()
    
    def setup_filter(self):
        """è®¾ç½®5Hzé«˜é€šæ»¤æ³¢å™¨"""
        try:
            cutoff_hz = self.param_manager.get_param("filtering", "highpass_cutoff_hz")
            filter_order = self.param_manager.get_param("filtering", "filter_order")
            
            # è®¾è®¡Butterworthé«˜é€šæ»¤æ³¢å™¨
            nyquist = 500.0  # 1000Hzé‡‡æ ·ç‡çš„å¥ˆå¥æ–¯ç‰¹é¢‘ç‡
            normalized_cutoff = cutoff_hz / nyquist
            
            self.sos = signal.butter(filter_order, normalized_cutoff, 
                                   btype='high', analog=False, output='sos')
            
            # åˆå§‹åŒ–æ»¤æ³¢å™¨çŠ¶æ€
            zi_template = signal.sosfilt_zi(self.sos)
            self.zi_x = zi_template.copy()
            self.zi_y = zi_template.copy()
            self.zi_z = zi_template.copy()
            
            self.filter_initialized = True
            print(f"é«˜é€šæ»¤æ³¢å™¨åˆå§‹åŒ–å®Œæˆ: {cutoff_hz}Hz, {filter_order}é˜¶")
            
        except Exception as e:
            print(f"æ»¤æ³¢å™¨åˆå§‹åŒ–å¤±è´¥: {e}")
            self.filter_initialized = False
```

#### 2.2 æ»¤æ³¢å¤„ç†å®ç°
```python
def apply_highpass_filter(self, data):
    """åº”ç”¨é«˜é€šæ»¤æ³¢å™¨ - æ”¯æŒå•ç‚¹å’Œæ‰¹é‡å¤„ç†"""
    if not self.filter_initialized:
        return data
    
    try:
        data = np.array(data)
        
        # å¤„ç†å•ä¸ªæ•°æ®ç‚¹ [x, y, z]
        if data.shape == (3,):
            return self._filter_single_point(data)
        
        # å¤„ç†æ•°æ®åºåˆ— (N, 3) æˆ– (3, N)
        elif data.ndim == 2:
            if data.shape[1] == 3:  # (N, 3) æ ¼å¼
                return self._filter_sequence(data)
            elif data.shape[0] == 3:  # (3, N) æ ¼å¼
                return self._filter_sequence(data.T).T
        
        return data
        
    except Exception as e:
        print(f"æ»¤æ³¢å¤„ç†å¤±è´¥: {e}")
        return data

def _filter_single_point(self, data_point):
    """æ»¤æ³¢å•ä¸ªæ•°æ®ç‚¹"""
    try:
        filtered_point = np.zeros(3)
        
        # å¯¹æ¯ä¸ªè½´åˆ†åˆ«æ»¤æ³¢
        for axis in range(3):
            filtered_value, zi_final = signal.sosfilt(
                self.sos, [data_point[axis]], zi=getattr(self, f'zi_{["x", "y", "z"][axis]}')
            )
            filtered_point[axis] = filtered_value[0]
            # æ›´æ–°æ»¤æ³¢å™¨çŠ¶æ€
            setattr(self, f'zi_{["x", "y", "z"][axis]}', zi_final)
        
        return filtered_point
        
    except Exception as e:
        print(f"å•ç‚¹æ»¤æ³¢å¤±è´¥: {e}")
        return data_point
```

### 3. æ™ºèƒ½æ£€æµ‹æ¨¡å—

#### 3.1 ç²—æ£€æµ‹å™¨ (CoarseDetectorç±»)
```python
class CoarseDetector:
    def __init__(self, param_manager):
        self.param_manager = param_manager
        self.data_buffer = deque(maxlen=2000)  # 2ç§’æ•°æ®ç¼“å­˜
        self.baseline_rms = 0.005  # å›ºå®šåŸºçº¿RMSå€¼ï¼Œè®¾ç½®ä¸º5mg
        self.last_trigger_time = 0
        self.trigger_start_time = 0
        self.is_triggered = False
        self.baseline_initialized = True   # å¼ºåˆ¶ä½¿ç”¨å›ºå®šåŸºçº¿
    
    def detect(self, accel_data):
        """æ‰§è¡Œç²—æ£€æµ‹"""
        try:
            # æ·»åŠ æ•°æ®åˆ°ç¼“å­˜
            self.data_buffer.append(accel_data)
            
            # ç¼“å­˜ä¸è¶³æ—¶è¿”å›
            if len(self.data_buffer) < 100:
                return {'result': 'insufficient_data', 'confidence': 0.0}
            
            # è®¡ç®—ç‰¹å¾
            recent_data = np.array(list(self.data_buffer)[-100:])  # æœ€è¿‘100ä¸ªç‚¹
            magnitude = np.sqrt(np.sum(recent_data**2, axis=1))
            
            # RMSè®¡ç®—
            rms = np.sqrt(np.mean(magnitude**2))
            
            # å³°å€¼å› å­è®¡ç®—
            peak_factor = np.max(magnitude) / rms if rms > 0 else 0
            
            # é˜ˆå€¼æ£€æŸ¥
            rms_threshold = self.baseline_rms * self.param_manager.get_param("coarse_detection", "rms_threshold_multiplier")
            peak_factor_threshold = self.param_manager.get_param("coarse_detection", "peak_factor_threshold")
            duration_threshold = self.param_manager.get_param("coarse_detection", "duration_threshold_sec")
            
            current_time = time.time()
            
            # è§¦å‘æ¡ä»¶æ£€æŸ¥
            if rms > rms_threshold and peak_factor > peak_factor_threshold:
                if not self.is_triggered:
                    self.is_triggered = True
                    self.trigger_start_time = current_time
                    print(f"ğŸ” ç²—æ£€æµ‹è§¦å‘: RMS={rms:.4f}g (é˜ˆå€¼={rms_threshold:.4f}g), å³°å€¼å› å­={peak_factor:.2f}")
                
                # æ£€æŸ¥æŒç»­æ—¶é—´
                trigger_duration = current_time - self.trigger_start_time
                if trigger_duration >= duration_threshold:
                    self.last_trigger_time = current_time
                    return {
                        'result': 'triggered',
                        'confidence': min(0.9, (rms / rms_threshold) * 0.5 + (peak_factor / peak_factor_threshold) * 0.4),
                        'features': {
                            'rms': rms,
                            'peak_factor': peak_factor,
                            'duration': trigger_duration,
                            'baseline_rms': self.baseline_rms
                        }
                    }
            else:
                # é‡ç½®è§¦å‘çŠ¶æ€
                if self.is_triggered:
                    print(f"ğŸ” ç²—æ£€æµ‹é‡ç½®: RMS={rms:.4f}g, å³°å€¼å› å­={peak_factor:.2f}")
                    self.is_triggered = False
            
            return {'result': 'normal', 'confidence': 0.0}
            
        except Exception as e:
            print(f"ç²—æ£€æµ‹æ‰§è¡Œå¤±è´¥: {e}")
            return {'result': 'error', 'confidence': 0.0}
```

#### 3.2 ç»†æ£€æµ‹å™¨ (FineDetectorç±»)
```python
class FineDetector:
    def __init__(self, param_manager):
        self.param_manager = param_manager
        self.is_trained = True  # è§„åˆ™åˆ†ç±»å™¨ä¸éœ€è¦è®­ç»ƒ
        self.setup_classifier()
    
    def setup_classifier(self):
        """è®¾ç½®è§„åˆ™åˆ†ç±»å™¨"""
        try:
            # è§„åˆ™åˆ†ç±»å™¨çš„å‚æ•°
            self.mining_rules = {
                'low_freq_threshold': 0.4,      # ä½é¢‘èƒ½é‡æ¯”é˜ˆå€¼
                'mid_freq_threshold': 0.2,      # ä¸­é¢‘èƒ½é‡æ¯”é˜ˆå€¼
                'dominant_freq_max': 50,        # ä¸»é¢‘æœ€å¤§å€¼
                'spectral_centroid_max': 80,    # é¢‘è°±é‡å¿ƒæœ€å¤§å€¼
                'harmonic_strength_min': 0.1    # è°æ³¢å¼ºåº¦æœ€å°å€¼
            }
            print("è§„åˆ™åˆ†ç±»å™¨åˆå§‹åŒ–å®Œæˆ")
        except Exception as e:
            print(f"åˆ†ç±»å™¨åˆå§‹åŒ–å¤±è´¥: {e}")
            self.is_trained = False
    
    def classify(self, frequencies, magnitudes):
        """ä½¿ç”¨è§„åˆ™åˆ†ç±»å™¨è¿›è¡Œåˆ†ç±»"""
        try:
            if not self.is_trained:
                return {'result': 'error', 'confidence': 0.0, 'features': None}
            
            # æå–é¢‘åŸŸç‰¹å¾
            features = self._extract_frequency_features(frequencies, magnitudes)
            
            # åº”ç”¨è§„åˆ™åˆ†ç±»
            confidence = 0.0
            mining_indicators = 0
            total_rules = 5
            
            # è§„åˆ™1: ä½é¢‘èƒ½é‡æ¯” (0-15Hz)
            if features[0] > self.mining_rules['low_freq_threshold']:
                confidence += 0.3
                mining_indicators += 1
            
            # è§„åˆ™2: ä¸­é¢‘èƒ½é‡æ¯” (15-50Hz)
            if features[1] > self.mining_rules['mid_freq_threshold']:
                confidence += 0.2
                mining_indicators += 1
            
            # è§„åˆ™3: ä¸»é¢‘ä½ç½®
            if features[2] < self.mining_rules['dominant_freq_max']:
                confidence += 0.2
                mining_indicators += 1
            
            # è§„åˆ™4: é¢‘è°±é‡å¿ƒ
            if features[3] < self.mining_rules['spectral_centroid_max']:
                confidence += 0.15
                mining_indicators += 1
            
            # è§„åˆ™5: è°æ³¢å¼ºåº¦
            if features[4] > self.mining_rules['harmonic_strength_min']:
                confidence += 0.15
                mining_indicators += 1
            
            # ç»¼åˆåˆ¤æ–­
            confidence_threshold = self.param_manager.get_param("fine_detection", "confidence_threshold")
            
            if confidence >= confidence_threshold:
                result = 'mining'
                print(f"ğŸ¯ ç»†æ£€æµ‹: æŒ–æ˜æ´»åŠ¨ (ç½®ä¿¡åº¦={confidence:.2f}, æŒ‡æ ‡={mining_indicators}/{total_rules})")
            else:
                result = 'normal'
            
            return {
                'result': result,
                'confidence': confidence,
                'features': features,
                'mining_indicators': mining_indicators,
                'total_rules': total_rules
            }
            
        except Exception as e:
            print(f"åˆ†ç±»å¤±è´¥: {e}")
            return {'result': 'error', 'confidence': 0.0, 'features': None}
```

### 4. ä¸»ç•Œé¢æ¨¡å— (VibrAnalyzerç±»)

#### 4.1 ç•Œé¢æ¶æ„
```python
class VibrAnalyzer:
    def __init__(self, root):
        self.root = root
        self.root.title("ä¸“ä¸šæŒ¯åŠ¨åˆ†æä»ª v3.1 - æ™ºèƒ½æŒ–æ˜æ£€æµ‹ç³»ç»Ÿ")
        self.root.geometry("1400x1100")
        
        # çº¿ç¨‹å®‰å…¨æœºåˆ¶
        self._state_lock = threading.Lock()  # ä¿æŠ¤å…±äº«çŠ¶æ€
        self._serial_lock = threading.Lock()  # ä¿æŠ¤ä¸²å£æ“ä½œ
        
        # æ•°æ®ç›¸å…³
        self.serial_conn = None
        self.parser = ProtocolParser()
        self.data_queue = queue.Queue()
        self._running = False
        
        # åŸå§‹åŠ é€Ÿåº¦æ•°æ®ç¼“å­˜
        self.raw_accel_buffer = {
            'x': deque(maxlen=1000),
            'y': deque(maxlen=1000),
            'z': deque(maxlen=1000),
            'time': deque(maxlen=1000)
        }
        
        # æ™ºèƒ½æ£€æµ‹ç³»ç»Ÿåˆå§‹åŒ–
        self.param_manager = ParameterManager()
        self.data_preprocessor = DataPreprocessor(self.param_manager)
        self.coarse_detector = CoarseDetector(self.param_manager)
        self.detection_logger = DetectionLogger()
        self.event_recorder = MiningEventRecorder()
        
        # æ£€æµ‹æ§åˆ¶å‚æ•°
        self.detection_mode = tk.StringVar(value="ä¸¤çº§æ£€æµ‹")
        self.sensitivity_level = tk.StringVar(value="ä¸­ç­‰")
        self.detection_enabled = tk.BooleanVar(value=True)
        self.stm32_alarm_enabled = tk.BooleanVar(value=True)  # STM32æŠ¥è­¦è§¦å‘å¼€å…³
        
        self.setup_ui()
        self.setup_plot()
        self.init_fine_detector()
```

#### 4.2 åŒè§†å›¾æ˜¾ç¤ºå®ç°
```python
def setup_plot(self):
    """è®¾ç½®åŒè§†å›¾ç»˜å›¾"""
    # åˆ›å»ºå›¾å½¢å’Œå­å›¾
    self.fig = Figure(figsize=(14, 10), dpi=100)
    
    # ä¸Šæ–¹é¢‘åŸŸå›¾è¡¨
    self.ax = self.fig.add_subplot(211)
    self.ax.set_xlabel('é¢‘ç‡ (Hz)')
    self.ax.set_ylabel('å¹…åº¦ (g)')
    self.ax.set_title('æŒ¯åŠ¨é¢‘åŸŸåˆ†æ')
    self.ax.grid(True, alpha=0.3)
    
    # ä¸‹æ–¹æ—¶åŸŸå›¾è¡¨
    self.raw_ax = self.fig.add_subplot(212)
    self.raw_ax.set_xlabel('æ—¶é—´ (s)')
    self.raw_ax.set_ylabel('åŠ é€Ÿåº¦ (g)')
    self.raw_ax.set_title('å®æ—¶åŸå§‹åŠ é€Ÿåº¦æ•°æ®')
    self.raw_ax.grid(True, alpha=0.3)
    
    # è°ƒæ•´å­å›¾é—´è·
    self.fig.tight_layout(pad=3.0)
    
    # åˆ›å»ºç”»å¸ƒ
    self.canvas = FigureCanvasTkAgg(self.fig, self.plot_frame)
    self.canvas.draw()
    self.canvas.get_tk_widget().pack(fill=tk.BOTH, expand=True)
    
    # åˆ›å»ºå·¥å…·æ 
    self.toolbar = NavigationToolbar2Tk(self.canvas, self.plot_frame)
    self.toolbar.update()
```

#### 4.3 æ™ºèƒ½æ£€æµ‹é›†æˆ
```python
def perform_intelligent_detection(self, frame):
    """æ‰§è¡Œæ™ºèƒ½æ£€æµ‹"""
    try:
        if not self.detection_enabled.get():
            return
        
        if frame['type'] == 'raw_accel':
            # æ‰§è¡Œç²—æ£€æµ‹
            coarse_result = self.perform_coarse_detection(frame)
            
            if coarse_result['result'] == 'triggered':
                self.coarse_detection_triggered = True
                print(f"ğŸ” ç²—æ£€æµ‹è§¦å‘ï¼Œç½®ä¿¡åº¦: {coarse_result['confidence']:.2f}")
                
                # è®°å½•ç²—æ£€æµ‹ç»“æœ
                self.record_detection_result('coarse_triggered', coarse_result['confidence'], 'coarse')
        
        elif frame['type'] == 'spectrum' and self.coarse_detection_triggered:
            # æ‰§è¡Œç»†æ£€æµ‹
            fine_result = self.perform_fine_detection(frame)
            
            if fine_result['result'] == 'mining':
                print(f"ğŸ¯ ç»†æ£€æµ‹ç¡®è®¤æŒ–æ˜æ´»åŠ¨ï¼Œç½®ä¿¡åº¦: {fine_result['confidence']:.2f}")
                
                # è®°å½•æ£€æµ‹ç»“æœ
                self.record_detection_result('mining', fine_result['confidence'], 'fine')
                
                # å‘é€è§¦å‘æŠ¥è­¦å‘½ä»¤ç»™STM32
                self.send_alarm_trigger_to_stm32()
                
                # é‡ç½®ç²—æ£€æµ‹çŠ¶æ€
                self.coarse_detection_triggered = False
            
            elif fine_result['result'] == 'normal':
                print(f"ğŸ” ç»†æ£€æµ‹åˆ¤å®šä¸ºæ­£å¸¸ï¼Œç½®ä¿¡åº¦: {fine_result['confidence']:.2f}")
                self.coarse_detection_triggered = False
                
    except Exception as e:
        print(f"æ™ºèƒ½æ£€æµ‹æ‰§è¡Œå¤±è´¥: {e}")

def send_alarm_trigger_to_stm32(self):
    """å‘é€è§¦å‘æŠ¥è­¦å‘½ä»¤ç»™STM32"""
    try:
        if not self.stm32_alarm_enabled.get():
            print("â„¹ï¸ STM32æŠ¥è­¦è§¦å‘åŠŸèƒ½å·²ç¦ç”¨ï¼Œè·³è¿‡å‘é€å‘½ä»¤")
            return False
        
        serial_conn = self.get_serial_connection()
        
        if serial_conn and serial_conn.is_open:
            command = bytes([0x10])
            serial_conn.write(command)
            print(f"ğŸš¨ å·²å‘é€è§¦å‘æŠ¥è­¦å‘½ä»¤ç»™STM32: 0x{command[0]:02X}")
            self.detection_logger.logger.info(f"å‘é€STM32è§¦å‘æŠ¥è­¦å‘½ä»¤: 0x{command[0]:02X}")
            return True
        else:
            print("âš ï¸ ä¸²å£æœªè¿æ¥ï¼Œæ— æ³•å‘é€è§¦å‘æŠ¥è­¦å‘½ä»¤")
            return False
    except Exception as e:
        print(f"âŒ å‘é€è§¦å‘æŠ¥è­¦å‘½ä»¤å¤±è´¥: {e}")
        return False
```

### 5. æ—¥å¿—è®°å½•æ¨¡å—

#### 5.1 æ£€æµ‹æ—¥å¿—å™¨ (DetectionLoggerç±»)
```python
class DetectionLogger:
    def __init__(self, log_file='detection_history.log'):
        self.log_file = log_file
        self.logger = self._setup_logger()
    
    def _setup_logger(self):
        """è®¾ç½®æ—¥å¿—è®°å½•å™¨"""
        logger = logging.getLogger('DetectionLogger')
        logger.setLevel(logging.INFO)
        
        # æ–‡ä»¶å¤„ç†å™¨
        file_handler = logging.FileHandler(self.log_file, encoding='utf-8')
        file_handler.setLevel(logging.INFO)
        
        # æ ¼å¼åŒ–å™¨
        formatter = logging.Formatter('%(asctime)s | %(levelname)s | %(message)s', 
                                    datefmt='%Y-%m-%d %H:%M:%S')
        file_handler.setFormatter(formatter)
        
        logger.addHandler(file_handler)
        return logger
    
    def log_mining_event(self, event_data):
        """è®°å½•æŒ–æ˜äº‹ä»¶"""
        try:
            event_type = event_data.get('detection_type', 'unknown')
            confidence = event_data.get('confidence', 0.0)
            intensity = event_data.get('intensity', 'æœªçŸ¥')
            
            log_message = f"æŒ–æ˜æ£€æµ‹ | ç±»å‹: {event_type} | ç½®ä¿¡åº¦: {confidence:.2f} | å¼ºåº¦: {intensity}"
            
            if 'features' in event_data:
                features = event_data['features']
                if 'coarse_features' in features:
                    cf = features['coarse_features']
                    log_message += f" | RMS: {cf.get('rms', 0):.4f}g | å³°å€¼å› å­: {cf.get('peak_factor', 0):.2f}"
                
                if 'fine_features' in features:
                    ff = features['fine_features']
                    log_message += f" | ä¸»é¢‘: {ff.get('dominant_frequency', 0):.1f}Hz"
            
            self.logger.info(log_message)
            
        except Exception as e:
            self.logger.error(f"è®°å½•æŒ–æ˜äº‹ä»¶å¤±è´¥: {e}")
```

#### 5.2 äº‹ä»¶è®°å½•å™¨ (MiningEventRecorderç±»)
```python
class MiningEventRecorder:
    def __init__(self, json_file='mining_events.json'):
        self.json_file = json_file
        self.events = []
        self.load_existing_events()
    
    def record_mining_event(self, event_data):
        """è®°å½•è¯¦ç»†çš„æŒ–æ˜äº‹ä»¶æ•°æ®"""
        try:
            # æ·»åŠ åˆ°å†…å­˜åˆ—è¡¨
            self.events.append(event_data)
            
            # ä¿æŒæœ€è¿‘1000ä¸ªäº‹ä»¶
            if len(self.events) > 1000:
                self.events = self.events[-1000:]
            
            # ä¿å­˜åˆ°JSONæ–‡ä»¶
            self.save_events_to_file()
            
            print(f"ğŸ“ æŒ–æ˜äº‹ä»¶å·²è®°å½•: ç½®ä¿¡åº¦={event_data.get('confidence', 0):.2f}")
            
        except Exception as e:
            print(f"è®°å½•æŒ–æ˜äº‹ä»¶å¤±è´¥: {e}")
    
    def save_events_to_file(self):
        """ä¿å­˜äº‹ä»¶åˆ°JSONæ–‡ä»¶"""
        try:
            with open(self.json_file, 'w', encoding='utf-8') as f:
                json.dump(self.events, f, ensure_ascii=False, indent=2, default=str)
        except Exception as e:
            print(f"ä¿å­˜äº‹ä»¶æ–‡ä»¶å¤±è´¥: {e}")
```

## ğŸ”§ å…³é”®æŠ€æœ¯ç‰¹æ€§

### 1. å¤šçº¿ç¨‹æ¶æ„
- **æ•°æ®æ¥æ”¶çº¿ç¨‹**: ç‹¬ç«‹å¤„ç†ä¸²å£æ•°æ®æ¥æ”¶
- **æ•°æ®å¤„ç†çº¿ç¨‹**: ä¸»çº¿ç¨‹å¤„ç†æ•°æ®è§£æå’Œæ˜¾ç¤º
- **çº¿ç¨‹å®‰å…¨**: ä½¿ç”¨é”æœºåˆ¶ä¿æŠ¤å…±äº«èµ„æº

### 2. å®æ—¶æ•°æ®å¤„ç†
- **å¾ªç¯ç¼“å†²åŒº**: é«˜æ•ˆçš„æ•°æ®ç¼“å­˜ç®¡ç†
- **å¢é‡æ›´æ–°**: åªæ›´æ–°å˜åŒ–çš„å›¾è¡¨åŒºåŸŸ
- **å†…å­˜ç®¡ç†**: è‡ªåŠ¨æ¸…ç†è¿‡æœŸæ•°æ®ï¼Œé˜²æ­¢å†…å­˜æ³„æ¼

### 3. æ™ºèƒ½æ£€æµ‹ç®—æ³•
- **ä¸¤çº§æ£€æµ‹**: ç²—æ£€æµ‹å¿«é€Ÿç­›é€‰ï¼Œç»†æ£€æµ‹ç²¾ç¡®åˆ†ç±»
- **è‡ªé€‚åº”é˜ˆå€¼**: æ ¹æ®ç¯å¢ƒå™ªå£°åŠ¨æ€è°ƒæ•´æ£€æµ‹å‚æ•°
- **ç‰¹å¾å·¥ç¨‹**: å¤šç»´åº¦ç‰¹å¾æå–å’Œåˆ†æ

### 4. ç”¨æˆ·ä½“éªŒä¼˜åŒ–
- **åŒè§†å›¾æ˜¾ç¤º**: é¢‘åŸŸå’Œæ—¶åŸŸåŒå±å¯¹æ¯”
- **å®æ—¶æ§åˆ¶**: åŠ¨æ€è°ƒæ•´æ˜¾ç¤ºå‚æ•°å’Œæ£€æµ‹è®¾ç½®
- **çŠ¶æ€åé¦ˆ**: å®Œæ•´çš„ç³»ç»ŸçŠ¶æ€å’Œæ£€æµ‹ç»“æœæ˜¾ç¤º

## ğŸ“Š æ€§èƒ½æŒ‡æ ‡

| æŒ‡æ ‡ | æ•°å€¼ | è¯´æ˜ |
|------|------|------|
| ç•Œé¢æ›´æ–°ç‡ | 10-20 FPS | æµç•…çš„å®æ—¶æ˜¾ç¤º |
| æ•°æ®å¤„ç†å»¶è¿Ÿ | <50ms | ä½å»¶è¿Ÿæ•°æ®å¤„ç† |
| æ£€æµ‹å‡†ç¡®ç‡ | >90% | æ™ºèƒ½æ£€æµ‹ç®—æ³• |
| è¯¯æŠ¥ç‡ | <10% | ä¸¤çº§æ£€æµ‹ä¼˜åŒ– |
| å†…å­˜å ç”¨ | <100MB | é«˜æ•ˆå†…å­˜ç®¡ç† |
| CPUå ç”¨ | <20% | ä¼˜åŒ–çš„ç®—æ³•å®ç° |
| æ”¯æŒæ•°æ®æ ¼å¼ | 3ç§ | 21ç‚¹/257ç‚¹/åŸå§‹æ•°æ® |
| æ—¥å¿—è®°å½• | å®Œæ•´ | å¤šçº§æ—¥å¿—ç³»ç»Ÿ |

---

**Pythonæ™ºèƒ½æŒ–æ˜æ£€æµ‹ä¸Šä½æœº v3.3 - ä¸“ä¸šæŒ¯åŠ¨åˆ†æä¸æ™ºèƒ½æŠ¥è­¦** ğŸš€
